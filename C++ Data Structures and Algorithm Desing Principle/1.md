---
sort: 1
---

# 리스트, 스택, 큐

```note
- [ ] 응용 프로그램에 적합한 자료 구조를 사용하는 것이 얼마나 중요한지
- [ ] 주어진 문제에 적합한 C++ 내장 자료 구조를 이용하여 응용 프로그램을 쉽게 개발
- [ ] C++에서 제곧ㅇ하는 기능이 주어진 상황에 충분한 역할을 수행하기 어려운 경우, 적절한 사용자 정의 선형 자료 구조를 구현할 수 있는지
- [ ] 다양한 유형의 선형 자료 구조가 사용될 수 있는 실제 문제를 분석할 수 있고, 주어진 문제에 가장 적합한 자료 구조를 선택할 수 있는지
```

## Keywords :key:

- [ ] 리스트
- [ ] 스택
- [ ] 큐

## 들어가며 :door:
- C++에서 제공되는 기본적이고 널리 사용되는 선형 자료 구조(linear data structures) 소개
- 각각의 설계 구조와 장단점에 대해 알아볼 것
- 연습 문제를 통해 다양한 자료 구조 구현

```note
자료 구조를 제대로 이해하고 있으면 응용 프로그램의 성능 향상, 표준화, 가독성, 유지 보수 등의 관점에서 유리하게 데이터를 관리할 수 있다.
```

## 연속된 자료 구조와 연결된 자료 구조

자료 구조는 크게 연속된 자료 구조와 연결된 자료 구조로 구분된다.

### 연속된 자료 구조 (contiguouse data structures)

연속된 자료 구조는 모든 원소를 단일 메모리 청크에 저장한다. 각각의 원소는 모두 같은 타입을 사용한다. 따라서 모든 원소는 같은 크기의 메모리를 사용하고, 이는 _sizeof(type)_ 으로 표시된다. 첫 번째 원소의 메모리 주소를 **시작 주소** (BA, Base Address)라고 한다. 모든 원소가 같은 타입이기 때문에 두 번째 원소의 위치는 _BA + sizeof(type)_ 이고, 그다음 원소의 위치는 _BA + 2 x sizeof(type)_ 이 된다. 즉, _i_ 번째 원소에 접근하려면 _BA + i x sizeof(type)_ 수식을 사용한다. <br>
이러한 자료 구조에서는 배열의 전체 크기에 상관없이 앞서 설명한 수식을 이용하여 모든 원소에 곧바로 접근할 수 있다. 따라서 데이터 접근 시간은 항상 일정하다. 이러한 경우를 빅오 (Big-O) 표기법으로 나타내면 __O(i)__ 로 표시한다. <br>
배열의 유형은 정적 배열(static array)과 동적 배열(dynamic array)로 나눈다. 정적 배열은 선언된 블록이 끝나면 소멸되는 반면, 동적 배열은 프로그래머가 생성할 시점과 해제할 시점을 자유롭게 결정할 수 있다. 이러한 배열은 C언어에서 도입되었기 때문에 C스타일 배열이라고도 한다. 실제로 배열을 선언하는 방법은 다음과 같다.
- 정적 배열은 `int arr[size];` 형태로 선언한다.
- C에서 동적 배열은 `int* arr = (int*)malloc(size*sizeof(int));` 형태로 선언한다.
- C++에서 동적 배열은 `int* arr = new int[size];` 형태로 선언한다.
정적 배열은 스택(stack) 메모리 영역에 할당되기 때문에 함수를 벗어날 때 자동으로 해제된다. 반면에 동적 배열은 힙(heap) 영역에 할당되며 사용자가 직접 해제하기 전까지 유지된다.<br>
배열 같은 연속된 자료 구조에서 각 원소는 서로 인접해 있기 때문에 하나의 원소에 접근할 때 그 옆에 있는 원소 몇 개도 함께 캐시(cache)로 가져온다. 그러므로 다시 주변 원소에 접근할 때에는 해당 원소를 캐시에서 가져오게 되며, 이 작업은 매우 빠르게 동작한다. 이러한 속성을 캐시 지역성(cache locality)이라고 한다. 어떤 연산의 점근적 시간 복잡도(asymptotic time complexity)계산에는 영향을 주지 않지만 실제 동작에서 배열처럼 연속된 원소에 매우 빠르게 접근할 수 있다는 점은 큰 장점이 된다. 배열에서 모든 원소에 순차적으로 접근하는 경우, 첫 번째 원소를 가져온 후 다음 원소는 캐시에 바로 참조할 수 있으므로 배열은 캐시 지역성이 좋다고 말할 수 있다.

### 연결된 자료 구조



### 비교
### C 스타일 배열의 제약 사항

## std::array
### 연습 문제1: 동적 크기 배열 구현하기
### 연습 문제2: 빠르고 범용적인 데이터 저장 컨테이너 만들기

## std::vector
### ste::vector - 가변 크기 배열
### std::vector 할당자

## std::forward_list
### std::forward_list에서 원소 삽입과 삭제
### std::forward_list의 기타 멤버 함수

## 반복자
### 연습 문제4: 다양한 반복자에서 이동하기
### 연습 문제5: 기본적인 사용자 정의 컨테이너 만들기
### 실습 문제1: 음악 재생 목록 구현하기

## std::list
### std::list 멤버 함수
### 연습 문제6: std::list의 삽입 또는 삭제 함수 사용하기
### 양방향 반복자
### 반복자 무효화
### 실습 문제2: 카드 게임 시뮬레이션

## std::dequeue
### 덱의 구조

## 컨테이너 어댑터
### std::stack
### std::queue
### std::priority_queue
### 어댑터 반복자

## 벤치마킹
### 실습 문제3: 사무실 공유 프린터의 인쇄 대기 목록 시뮬레이션

## 나가며
