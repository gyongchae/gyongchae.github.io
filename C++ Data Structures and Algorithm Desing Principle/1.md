---
sort: 1
---

# 리스트, 스택, 큐

```note
- 응용 프로그램에 적합한 자료 구조를 사용하는 것이 얼마나 중요한지
- 주어진 문제에 적합한 C++ 내장 자료 구조를 이용하여 응용 프로그램을 쉽게 개발
- C++에서 제곧ㅇ하는 기능이 주어진 상황에 충분한 역할을 수행하기 어려운 경우, 적절한 사용자 정의 선형 자료 구조를 구현할 수 있는지
- 다양한 유형의 선형 자료 구조가 사용될 수 있는 실제 문제를 분석할 수 있고, 주어진 문제에 가장 적합한 자료 구조를 선택할 수 있는지
```

---

## Keywords :key:

- [ ] 리스트
- [ ] 스택
- [ ] 큐

---

## 들어가며 :door:
- C++에서 제공되는 기본적이고 널리 사용되는 선형 자료 구조(linear data structures) 소개
- 각각의 설계 구조와 장단점에 대해 알아볼 것
- 연습 문제를 통해 다양한 자료 구조 구현

```note
자료 구조를 제대로 이해하고 있으면 응용 프로그램의 성능 향상, 표준화, 가독성, 유지 보수 등의 관점에서 유리하게 데이터를 관리할 수 있다.
```

---

## 연속된 자료 구조와 연결된 자료 구조

자료 구조는 크게 연속된 자료 구조와 연결된 자료 구조로 구분된다.

### 연속된 자료 구조

**연속된 자료 구조(contiguous data structures)** 는 모든 원소를 단일 메모리 청크(chunk)에 저장한다. 각각의 원소는 모두 같은 타입을 사용한다. 다음 그림은 연속된 자료 구조에 데이터가 저장되는 방법을 보여준다.<br>

- [ ] 연속된 자료 구조를 표현한 다이어그램

그림에서 바깥쪽 큰 사각형은 모든 원소가 저장되어 있는 단일 메모리 청크를 나타내고, 안쪽 작은 사각형들은 각각의 원소가 저장된 메모리 공간을 의미한다. 이 그림에서 각각의 원소는 모두 같은 타입(type)을 사용한다. 그러므로 모든 원소는 같은 크기의 메모리를 사용하고, 이는 _sizeof(type)_ 으로 표시된다. 첫 번째 원소의 메모리 주소를 **시작 주소** (BA, Base Address)라고 한다. 모든 원소가 같은 타입이기 때문에 두 번째 원소의 위치는 _BA + sizeof(type)_ 이고, 그다음 원소의 위치는 _BA + 2 x sizeof(type)_ 이 된다. 즉, _i_ 번째 원소에 접근하려면 _BA + i x sizeof(type)_ 수식을 사용한다. <br>
이러한 자료 구조에서는 배열의 전체 크기에 상관없이 앞서 설명한 수식을 이용하여 모든 원소에 곧바로 접근할 수 있다. 따라서 데이터 접근 시간은 항상 일정하다. 이러한 경우를 빅오 (Big-O) 표기법으로 나타내면 __O(i)__ 로 표시한다. <br>
배열의 유형은 정적 배열(static array)과 동적 배열(dynamic array)로 나눈다. 정적 배열은 선언된 블록이 끝나면 소멸되는 반면, 동적 배열은 프로그래머가 생성할 시점과 해제할 시점을 자유롭게 결정할 수 있다. 이러한 배열은 C언어에서 도입되었기 때문에 C스타일 배열이라고도 한다. 실제로 배열을 선언하는 방법은 다음과 같다.

- 정적 배열은 `int arr[size];` 형태로 선언한다.
- C에서 동적 배열은 `int* arr = (int*)malloc(size*sizeof(int));` 형태로 선언한다.
- C++에서 동적 배열은 `int* arr = new int[size];` 형태로 선언한다.

정적 배열은 스택(stack) 메모리 영역에 할당되기 때문에 함수를 벗어날 때 자동으로 해제된다. 반면에 동적 배열은 힙(heap) 영역에 할당되며 사용자가 직접 해제하기 전까지 유지된다.<br>
배열 같은 연속된 자료 구조에서 각 원소는 서로 인접해 있기 때문에 하나의 원소에 접근할 때 그 옆에 있는 원소 몇 개도 함께 캐시(cache)로 가져온다. 그러므로 다시 주변 원소에 접근할 때에는 해당 원소를 캐시에서 가져오게 되며, 이 작업은 매우 빠르게 동작한다. 이러한 속성을 캐시 지역성(cache locality)이라고 한다. 어떤 연산의 점근적 시간 복잡도(asymptotic time complexity)계산에는 영향을 주지 않지만 실제 동작에서 배열처럼 연속된 원소에 매우 빠르게 접근할 수 있다는 점은 큰 장점이 된다. 배열에서 모든 원소에 순차적으로 접근하는 경우, 첫 번째 원소를 가져온 후 다음 원소는 캐시에 바로 참조할 수 있으므로 배열은 캐시 지역성이 좋다고 말할 수 있다.

### 연결된 자료 구조

**연결된 자료 구조(linked data structures)** 는 노드(node)라고 하는 여러 개의 메모리 청크에 데이터를 자정하며, 이 경우 서로 다른 메모리 위치에 데이터가 저장된다. 다음은 연결된 자료 구조에 데이터가 저장되는 방법을 타나내는 다이어그램이다.<br>

- [ ] 연결된 자료 구조

그림과 같은 형태로 구성된 자료 구조를 연결 리스트(linked list)라고 한다. 연결 리스트의 기본 구조에서 각각의 노드는 저장할 데이터와 다음 노트를 가리키는 포인터를 가지고 있다. 맨 마지막 노드에서는 다음 노드의 포인터 대신 자료 구조의 끝을 나타내는 NULL을 가진다. 연결 리스트에서 특정 원소에 접근 하려면 리스트의 시작 부분, 즉 헤드 부분부터 시작하여 원하는 원소에 도달할 때까지 _next 포인터_ 를 따라 이동해야 한다. 그러므로 i번째 원소에 접근하려면 연결 리스트 내부를 _i_ 번 이동하는 작업이 필요하다. 그러므로 원소 접근 시간은 노드 개수에 비례하며, 시간 복잡도를 표녀하면 __O(n)__ 이다.<br>
배열과 달리 연결 리스트는 포인터를 이용하여 원소의 삽입 또는 삭제를 매우 빠르게 수행할 수 있다.

#### 연결 리스트에 새로운 원소를 추가하는 방법
```plaintext
다음 그림은 연결 리스트 중간에 새로운 원소를 삽입하는 동작을 나타내는 다이어그램이다.

- [ ] 연결 리스트에 새 원소 추가하기

새로운 원소를 삽입하려면 일단 새로운 노드를 생성하고, 각 노드의 next 포인터를 수정해야 한다. 먼저 새로 추가한 노드(i = 2)의 next 포인터가 다음 노드(i = 3)를 가리키게 만든다. 그리고 이전 노드(i = 1)의 next 포인터가 다음 노드(i = 3)을 가리키던 것을 제거하고, 새로운 노드(i = 2)를 가리키도록 설정한다. 이러한 방식으로 새로운 노드가 연결 리스트에 추가된다.<br>
마찬가지로 기존 원소를 제거하려며내 삭제할 원소가 더 이상 연결 리스트에 연결되어 있지 않도록 next 포인터를 수정하면 된다. 그런 다음 해당 노드의 메모리 할당을 해제하거나 또는 다른 적절한 처리를 수행할 수 있다.<br>
연결 리스트에서는 원소가 메모리에 연속적으로 저장되지 않기 때문에 캐시 지역성을 기대할 수 없다. 즉, 현재 노드가 가리키는 다음 노드에 직접 방문하지 않고 다음 원소를 캐시로 가져올 수 있는 방법은 없다. 따라서 배열과 연결 리스트에서 모든 원소를 차례대로 방문하는 작업은 이론적으로 같은 시간 복잡도를 가지지만, 실제로는 연결 리스트의 성능이 조금 떨어진다.
```

### 비교

:arrow_down: 연속된 자료 구조와 연결된 자료 구조의 비교

| 연속된 자료 구조          | 연결된 자료 구조          |
| --------------- | -------------- |
| 모든 데이터가 메모리에 연속적으로 저장 | 데이터는 노드에 저장되고, 노드는 메모리 곳곳에 흩어져 있을 수 있음       |
| 임의 원소에 즉각적으로 접근할 수 있음          | 임의 원소에 접근하는 것은 선형 시간 복잡도를 가지며 느린편    |
| 데이터가 연속적으로 저장되어 있고, 캐시 지역성 효과로 인해 모든 데이터를 순회하는 것이 매우 빠름    | 캐시 지역성 효과가 없으므로 모든 데이터를 순회하는 것이 느린 편 |
| 데이터 저장을 위해 정확하게 데이터 크기만큼 메모리 사용 | 각 노드에서 포인터 저장을 위해 여분의 메모리 사용 | 

:arrow_down: 다양한 연산에 대한 배열과 연결 리스트의 시간 복잡도

| 파라미터 | 배열 | 연결 리스트 |
| ------ | --- | --------- |
| 임의 점급 | O(1) | O(n) |
| 맨 뒤에 원소 삽입 | O(1) | O(1) |
| 중간에 원소 삽입 | O(n) | O(1) |
| 캐시 지역성 | 있음 | 없음 |

```plaintext
구현할 작업의 요구 조건 및 사용 빈도에 따라 배열과 연결 리스트 중에서 하나를 선택하거나, 또는 두 개를 조합하여 응용 프로그램을 개발해야 한다.<br>
배열과 연결 리스트는 매우 범용적이며 많은 응용 프로그램에서 데이터를 저장하는 용도로 사용되고 있다. 그러므로 이들 자료 구조의 구현은 버그가 없어야 하며, 최대한 효율적으로 동작해야 한다. 사용자가 직접 이들 자료 구조를 구현하지 않아도 되도록 C++는 `std::array` , `std::vector` , `std::list` 같은 다양한 자료 구조 클래스를 제공한다.
```

### C 스타일 배열의 제약 사항

--- 

## std::array
### 연습 문제1: 동적 크기 배열 구현하기
### 연습 문제2: 빠르고 범용적인 데이터 저장 컨테이너 만들기

---

## std::vector
### ste::vector - 가변 크기 배열
### std::vector 할당자

---

## std::forward_list
### std::forward_list에서 원소 삽입과 삭제
### std::forward_list의 기타 멤버 함수

---

## 반복자
### 연습 문제4: 다양한 반복자에서 이동하기
### 연습 문제5: 기본적인 사용자 정의 컨테이너 만들기
### 실습 문제1: 음악 재생 목록 구현하기

---

## std::list
### std::list 멤버 함수
### 연습 문제6: std::list의 삽입 또는 삭제 함수 사용하기
### 양방향 반복자
### 반복자 무효화
### 실습 문제2: 카드 게임 시뮬레이션

---

## std::dequeue
### 덱의 구조

---

## 컨테이너 어댑터
### std::stack
### std::queue
### std::priority_queue
### 어댑터 반복자

---

## 벤치마킹
### 실습 문제3: 사무실 공유 프린터의 인쇄 대기 목록 시뮬레이션

---

## 나가며
